// ===================== Utils: Números & Datas & Escapes =====================

function escapeHtml(str) {
  return String(str ?? "")
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#39;");
}

function norm(s) {
  return String(s ?? "")
    .toLowerCase()
    .normalize("NFD")
    .replace(/\p{Diacritic}/gu, "");
}

function safeDateFromAny(val) {
  if (val == null || val === "") return null;

  if (typeof val === "string") {
    const m = val.trim().match(/^(\d{1,2})\/(\d{1,2})\/(\d{2,4})$/);
    if (m) {
      const [, dd, mm, yy] = m;
      const y2 = parseInt(yy, 10);
      const y = yy.length === 2 ? (y2 >= 70 ? 1900 + y2 : 2000 + y2) : y2;
      const d = new Date(Date.UTC(y, parseInt(mm, 10) - 1, parseInt(dd, 10)));
      if (
        d.getUTCFullYear() === y &&
        d.getUTCMonth() === parseInt(mm, 10) - 1 &&
        d.getUTCDate() === parseInt(dd, 10)
      )
        return d;
      return null;
    }
  }

  if (typeof val === "number") {
    const ms = val < 1e12 ? val * 1000 : val;
    const d = new Date(ms);
    return isNaN(d.getTime()) ? null : d;
  }

  const d = new Date(val);
  return isNaN(d.getTime()) ? null : d;
}

function formatDateBR(value, fourDigitsYear = false) {
  if (!value) return "—";
  const d = safeDateFromAny(value);
  if (!d) return escapeHtml(String(value));
  const dd = String(d.getUTCDate()).padStart(2, "0");
  const mm = String(d.getUTCMonth() + 1).padStart(2, "0");
  const yyyy = String(d.getUTCFullYear());
  const yy = yyyy.slice(-2);
  return `${dd}/${mm}/${fourDigitsYear ? yyyy : yy}`;
}

function parseNumber(v) {
  if (v == null || (typeof v === "string" && !v.trim())) return 0;
  if (typeof v === "number") return Number.isFinite(v) ? v : 0;
  if (typeof v === "string") {
    const s = v
      .trim()
      .replace(/[^\d,.-]/g, "")
      .replace(/\.(?=\d{3}(\D|$))/g, "")
      .replace(",", ".");
    const n = Number(s);
    return Number.isFinite(n) ? n : 0;
  }
  const n = Number(v);
  return Number.isFinite(n) ? n : 0;
}

const brlFmt = new Intl.NumberFormat("pt-BR", {
  style: "currency",
  currency: "BRL",
  maximumFractionDigits: 2,
});

const formatBRL = (n) => brlFmt.format(parseNumber(n));
const toCents = (n) => Math.round(parseNumber(n) * 100);
const fromCents = (c) => c / 100;

// ===================== Cores e Status =====================

function statusBg(status) {
  const s = norm(status);
  if (s.includes("perfeita")) return "#e8f5e9";
  if (s.includes("parcial")) return "#fff8e1";
  return "#ffebee";
}

function statusPillColor(status) {
  const s = norm(status);
  if (s.includes("perfeita")) return "#2e7d32";
  if (s.includes("parcial")) return "#f9a825";
  return "#c62828";
}

function getStatusPriority(status) {
  const s = norm(status);

  // 1º - Conciliação Perfeita
  if (s.includes("perfeita")) return 1;

  // 2º - Não pago / Pendente
  if (
    s.includes("pendente") ||
    s.includes("nao pago") ||
    s.includes("não pago")
  )
    return 2;

  // 3º - Pagamento superior / outros
  if (s.includes("superior") || s.includes("pagamento superior")) return 3;

  // fallback
  return 99;
}

// Bucket para cards-resumo
function statusBucketLabel(statusRaw) {
  const s = norm(statusRaw ?? "");
  if (s.includes("perfeita")) return "Conciliação Perfeita";
  if (s.includes("parcial")) return "Conciliação Parcial";
  return "Não Encontrado/Outros";
}

// ===================== Helpers =====================

function toArrayLaunch(v) {
  if (Array.isArray(v)) return v;
  if (v == null) return [];
  if (typeof v === "string")
    return v
      .split(",")
      .map((s) => s.trim())
      .filter(Boolean);
  return [String(v)];
}

function normalizeRows(items) {
  const rows = [];
  for (const it of items || []) {
    const d = it?.json?.data;
    if (Array.isArray(d)) rows.push(...d);
    else if (d && typeof d === "object") rows.push(d);
    else if (it?.json && typeof it.json === "object") rows.push(it.json);
    else if (it && typeof it === "object") rows.push(it);
  }
  return rows;
}

function pickDateCell(r, preferredField) {
  return preferredField && r?.[preferredField] != null
    ? r[preferredField]
    : r.data ??
        r.date ??
        r.dt ??
        r.data_nf ??
        r.dt_emissao ??
        r.emissao ??
        null;
}

// ---------- Config ----------
function getSortConfig(items) {
  const cfg = items?.[0]?.json || {};
  const orderRaw = (cfg.sortOrder || cfg.order || "").toString().toLowerCase();
  const sortOrder =
    orderRaw === "desc" || orderRaw === "descending" ? "desc" : "asc";
  const sortField = cfg.sortField || cfg.field || null;
  const sortBy = (cfg.sortBy || "status+date").toLowerCase();
  return { sortOrder, sortField, sortBy };
}

// ===================== Histórico =====================

function deriveHistory(r) {
  const origem = r?.historico_origem;
  let full = "";
  if (origem) {
    full = String(origem);
  } else {
    const hc = Array.isArray(r?.historico_credito)
      ? r.historico_credito
      : r?.historico_credito
      ? [r.historico_credito]
      : [];
    const hd = Array.isArray(r?.historico_debito)
      ? r.historico_debito
      : r?.historico_debito
      ? [r.historico_debito]
      : [];
    const uniq = [...new Set([...hc, ...hd].filter(Boolean).map(String))];
    full = uniq.join(" | ");
  }
  const trimmed = full.trim();
  if (!trimmed) return { display: "—", title: "" };

  const maxLen = 120;
  const display =
    trimmed.length > maxLen ? trimmed.slice(0, maxLen) + "…" : trimmed;
  return { display: escapeHtml(display), title: escapeHtml(trimmed) };
}

// ===================== Leitura flexível & Cálculo do Saldo Exercício =====================

function normalizeKeyName(k) {
  return String(k ?? "")
    .toLowerCase()
    .normalize("NFD")
    .replace(/\p{Diacritic}/gu, "")
    .replace(/[^a-z0-9]/g, "");
}

function pickFlexibleField(obj, candidateNames) {
  if (!obj || typeof obj !== "object") return undefined;
  const map = new Map();
  for (const key of Object.keys(obj)) {
    map.set(normalizeKeyName(key), key);
  }
  const targets = candidateNames.map(normalizeKeyName);

  // 1) exato
  for (const t of targets) if (map.has(t)) return obj[map.get(t)];
  // 2) começa com
  for (const t of targets)
    for (const [nk, orig] of map.entries())
      if (nk.startsWith(t)) return obj[orig];
  // 3) contém
  for (const t of targets)
    for (const [nk, orig] of map.entries())
      if (nk.includes(t)) return obj[orig];

  return undefined;
}

function readMoneyFieldFlexible(obj, candidateNames) {
  const v = pickFlexibleField(obj, candidateNames);
  if (
    v === undefined ||
    v === null ||
    (typeof v === "string" && v.trim() === "")
  )
    return null;
  return toCents(v);
}

// Regra: Saldo Exercício = Débito − Crédito (fallback)
function getSaldoExercicioCents(r, creditoCents, debitoCents) {
  // 1) Se houver um campo explícito, usa ele (aceita várias grafias)
  const explicit = readMoneyFieldFlexible(r, [
    "saldo_exercicio",
    "saldo exercicio",
    "saldo-exercicio",
    "saldoExercicio",
    "saldo_exerc",
    "saldo_exercicio_total",
    "saldo_exercício",
    "saldo",
  ]);
  if (explicit !== null) return explicit;

  // 2) Caso contrário, calcula: débito − crédito
  const c = Number.isFinite(creditoCents) ? creditoCents : 0;
  const d = Number.isFinite(debitoCents) ? debitoCents : 0;
  return d - c;
}

// ===================== HTML Builder =====================

function buildHtml(rows, sortOrder, sortField, sortBy) {
  const empresa = escapeHtml(rows[0]?.empresa ?? "");
  const cnpj = escapeHtml(rows[0]?.cnpj ?? "");

  // Precompute helpers por performance e sort estável
  const prepared = rows.map((r, idx) => {
    const dateCell = pickDateCell(r, sortField);
    const d = safeDateFromAny(dateCell);
    const ts = d ? d.getTime() : new Date("1900-01-01T00:00:00Z").getTime();

    // Crédito/Débito com fallback de nomes
    const creditoCents =
      readMoneyFieldFlexible(r, [
        "valor_creditado",
        "credito",
        "valor credito",
      ]) ?? 0;
    const debitoCents =
      readMoneyFieldFlexible(r, ["valor_debitado", "debito", "valor debito"]) ??
      0;

    const nfKey = String(r.nf ?? "").padStart(20, "0");
    const statusPri = getStatusPriority(r.status);

    return {
      r,
      idx,
      ts,
      creditoCents,
      debitoCents,
      nfKey,
      statusPri,
      dateCell,
      statusRaw: r.status ?? "",
    };
  });

  // --- Ordenação dinâmica (estável) ---
  prepared.sort((A, B) => {
    const a = A,
      b = B;
    let diff = 0;

    if (sortBy === "status" || sortBy === "status+date") {
      // agrupa por status primeiro (para subtotais)
      diff = a.statusPri - b.statusPri;
      if (diff !== 0) return sortOrder === "desc" ? -diff : diff;
    }

    if (sortBy === "date" || sortBy === "status+date") {
      diff = a.ts - b.ts;
      if (diff !== 0) return sortOrder === "desc" ? -diff : diff;
    }

    // tie-breaker determinístico
    diff =
      a.nfKey.localeCompare(b.nfKey) ||
      a.creditoCents - b.creditoCents ||
      a.idx - b.idx;
    return sortOrder === "desc" ? -diff : diff;
  });

  // Totais em centavos (cards)
  const totals = {
    "Conciliação Perfeita": { count: 0, credito: 0, debito: 0 },
    "Conciliação Parcial": { count: 0, credito: 0, debito: 0 },
    "Não Encontrado/Outros": { count: 0, credito: 0, debito: 0 },
  };
  let totalGeralCredito = 0;
  let totalGeralDebito = 0;

  // Helper: linha de subtotal por grupo
  function renderSubtotalRow(statusLabel, creditoSum, debitoSum) {
    return `
<tr style="background:#d7d7d7">
  <td colspan="2" style="font-weight:700">Subtotal</td>
  <td class="right" style="font-weight:700">${formatBRL(
    fromCents(creditoSum)
  )}</td>
  <td class="right" style="font-weight:700">${formatBRL(
    fromCents(debitoSum)
  )}</td>
  <td colspan="4"> </td>
</tr>`;
  }

  // Cabeçalho repetido dentro do <tbody>, usado após cada subtotal
  function renderHeaderRow() {
    return `
<tr>
  <th>Data</th>
  <th>NF</th>
  <th class="right">Valor Creditado</th>
  <th class="right">Valor Debitado</th>
  <th>Histórico</th>
  <th>Status</th>
  <!-- <th class="right">Saldo Exercício</th> -->
  <th>Lanç. Crédito</th>
  <th>Lanç. Débito</th>
</tr>`;
  }

  // Construção do corpo com subtotais por **statusRaw** e cabeçalho logo após cada subtotal
  let bodyRows = "";
  let currentLabel = null;
  let groupCred = 0;
  let groupDeb = 0;

  for (const {
    r,
    creditoCents,
    debitoCents,
    dateCell,
    statusRaw,
  } of prepared) {
    // inicia/fecha grupo
    if (currentLabel === null) {
      currentLabel = statusRaw;
      groupCred = 0;
      groupDeb = 0;
    } else if (statusRaw !== currentLabel) {
      // fecha grupo anterior com subtotal
      bodyRows += renderSubtotalRow(currentLabel, groupCred, groupDeb);
      // imediatamente abaixo do Subtotal, insere o cabeçalho para o próximo grupo
      bodyRows += renderHeaderRow();

      currentLabel = statusRaw;
      groupCred = 0;
      groupDeb = 0;
    }

    // acumula para grupo atual
    groupCred += creditoCents;
    groupDeb += debitoCents;

    // acumula para cards (bucket genérico)
    const bucket = statusBucketLabel(statusRaw);
    totals[bucket].count += 1;
    totals[bucket].credito += creditoCents;
    totals[bucket].debito += debitoCents;
    totalGeralCredito += creditoCents;
    totalGeralDebito += debitoCents;

    // linha normal
    const dataFmt = formatDateBR(dateCell);
    const nf =
      r.nf === null || r.nf === undefined || r.nf === ""
        ? "—"
        : escapeHtml(String(r.nf));
    const lcredArr = toArrayLaunch(r.lancamento_credito);
    const ldebArr = toArrayLaunch(r.lancamento_debito);
    const lcred = lcredArr.length ? escapeHtml(lcredArr.join(", ")) : "—";
    const ldeb = ldebArr.length ? escapeHtml(ldebArr.join(", ")) : "—";
    const saldoExCents = getSaldoExercicioCents(r, creditoCents, debitoCents);
    const hist = deriveHistory(r);
    const pillColor = statusPillColor(statusRaw);
    const statusTxt = escapeHtml(String(statusRaw));

    bodyRows += `
<tr style="background:${statusBg(statusRaw)}">
  <td>${dataFmt}</td>
  <td>${nf}</td>
  <td class="right">${formatBRL(fromCents(creditoCents))}</td>
  <td class="right">${formatBRL(fromCents(debitoCents))}</td>
  <td class="hist" title="${hist.title}">${hist.display}</td>
  <td>
    <span style="
      display:inline-block;padding:.25rem .5rem;border-radius:999px;font-weight:600;
      color:${pillColor};border:1px solid rgba(0,0,0,.08);background:#fff
    ">${statusTxt}</span>
  </td>
  <!-- <td class="right">${formatBRL(fromCents(saldoExCents))}</td> -->
  <td>${lcred}</td>
  <td>${ldeb}</td>
</tr>`;
  }

  // fecha o último grupo se houver linhas
  if (currentLabel !== null) {
    bodyRows += renderSubtotalRow(currentLabel, groupCred, groupDeb);
  }

  // (REMOVIDO) Linha final Totais do Relatório

  const legend = `
<div style="display:flex;gap:1rem;flex-wrap:wrap;margin:.5rem 0 1rem 0">
  <div><span style="display:inline-block;width:12px;height:12px;background:#e8f5e9;border:1px solid rgba(46,125,50,.2);margin-right:.4rem;vertical-align:middle"></span> Conciliação Perfeita</div>
  <div><span style="display:inline-block;width:12px;height:12px;background:#fff8e1;border:1px solid rgba(249,168,37,.2);margin-right:.4rem;vertical-align:middle"></span> Conciliação Parcial</div>
  <div><span style="display:inline-block;width:12px;height:12px;background:#ffebee;border:1px solid rgba(198,40,40,.2);margin-right:.4rem;vertical-align:middle"></span> Não Encontrado / Pendente / Outros</div>
</div>`;

  const totalsHtml = `
<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));gap:12px;margin:12px 0 20px 0">
  <div style="background:#e8f5e9;border:1px solid rgba(46,125,50,.2);border-radius:12px;padding:12px">
    <div style="font-size:12px;color:#2e7d32">Conciliação Perfeita</div>
    <div style="font-weight:700">${
      totals["Conciliação Perfeita"].count
    } lanç.</div>
    <div style="font-size:12px">Crédito ${formatBRL(
      fromCents(totals["Conciliação Perfeita"].credito)
    )} · Débito ${formatBRL(
    fromCents(totals["Conciliação Perfeita"].debito)
  )}</div>
  </div>
  <div style="background:#fff8e1;border:1px solid rgba(249,168,37,.2);border-radius:12px;padding:12px">
    <div style="font-size:12px;color:#f9a825">Conciliação Parcial</div>
    <div style="font-weight:700">${
      totals["Conciliação Parcial"].count
    } lanç.</div>
    <div style="font-size:12px">Crédito ${formatBRL(
      fromCents(totals["Conciliação Parcial"].credito)
    )} · Débito ${formatBRL(
    fromCents(totals["Conciliação Parcial"].debito)
  )}</div>
  </div>
  <div style="background:#ffebee;border:1px solid rgba(198,40,40,.2);border-radius:12px;padding:12px">
    <div style="font-size:12px;color:#c62828">Não Encontrado/Outros</div>
    <div style="font-weight:700">${
      totals["Não Encontrado/Outros"].count
    } lanç.</div>
    <div style="font-size:12px">Crédito ${formatBRL(
      fromCents(totals["Não Encontrado/Outros"].credito)
    )} · Débito ${formatBRL(
    fromCents(totals["Não Encontrado/Outros"].debito)
  )}</div>
  </div>
  <div style="background:#f5f5f5;border:1px solid #ddd;border-radius:12px;padding:12px">
    <div style="font-size:12px;color:#333">Total Geral</div>
    <div style="font-weight:700">Saldo: ${formatBRL(
      fromCents(totalGeralCredito - totalGeralDebito)
    )}</div>
    <div style="font-size:12px">Crédito ${formatBRL(
      fromCents(totalGeralCredito)
    )} · Débito ${formatBRL(fromCents(totalGeralDebito))}</div>
  </div>
</div>`;

  const generatedAt = new Date().toLocaleString("pt-BR", {
    timeZone: "America/Sao_Paulo",
  });

  return `<!doctype html>
<html lang="pt-br">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Relatório de Conciliação</title>
<style>
  body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Oxygen,Ubuntu,'Helvetica Neue',Arial,sans-serif;margin:24px;line-height:1.4}
  h1{margin:0 0 4px 0;font-weight:700;color:#222;font-size:1.7rem}
  .sub{font-size:12px;color:#444}
  table{border-collapse:collapse;width:100%}
  th,td{border:1px solid #ddd;padding:8px;vertical-align:top;color:#222}
  th{background:#f5f5f5;text-align:left}
  td{background:transparent}
  .right{text-align:right}
  .hist{max-width:520px;word-break:break-word}
</style>
</head>
<body>
  <h1>Relatório de Conciliação - ${empresa} - ${cnpj}</h1>
  <div class="sub">Gerado em ${generatedAt}</div>
  ${legend}
  ${totalsHtml}
  <table>
    <thead>
      <tr>
        <th>Data</th>
        <th>NF</th>
        <th class="right">Valor Creditado</th>
        <th class="right">Valor Debitado</th>
        <th>Histórico</th>
        <th>Status</th>
        <!-- <th class="right">Saldo Exercício</th> -->
        <th>Lanç. Crédito</th>
        <th>Lanç. Débito</th>
      </tr>
    </thead>
    <tbody>
      ${bodyRows}
    </tbody>
  </table>
</body>
</html>`;
}

// ===================== Execução no n8n =====================

const rows = normalizeRows(items);
const { sortOrder, sortField, sortBy } = getSortConfig(items);

const html = rows.length
  ? buildHtml(rows, sortOrder, sortField, sortBy)
  : `<!doctype html><meta charset="utf-8"><title>Relatório de Conciliação</title>
     <div style="font-family:system-ui;margin:24px">
       <h1>Relatório de Conciliação</h1>
       <p>Nenhuma linha para exibir.</p>
     </div>`;

return [
  {
    json: {
      fileName: "relatorio_conciliacao.html",
      mimeType: "text/html",
      note: `HTML gerado. Ordenação: ${sortBy} (${sortOrder})${
        sortField ? `, campo: ${sortField}` : ""
      }.`,
    },
    binary: {
      data: {
        data: Buffer.from(html, "utf8").toString("base64"),
        mimeType: "text/html",
        fileName: "relatorio_conciliacao.html",
      },
    },
  },
];
















/* ATUAL
// ===================== Utils: Números & Datas & Escapes =====================

function escapeHtml(str) {
  return String(str ?? '')
    .replace(/&/g, '&amp;').replace(/</g, '&lt;')
    .replace(/>/g, '&gt;').replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

function norm(s) {
  const base = String(s ?? '').toLowerCase().normalize('NFD');
  let noDia;
  try {
    noDia = base.replace(/\p{Diacritic}/gu, '');
  } catch {
    noDia = base.replace(/[\u0300-\u036f]/g, '');
  }
  // Colapsa qualquer whitespace (inclui NBSP) e remove pontas
  return noDia.replace(/\s+/g, ' ').trim();
}

function safeDateFromAny(val) {
  if (val == null || val === '') return null;

  if (typeof val === 'string') {
    const m = val.trim().match(/^(\d{1,2})\/(\d{1,2})\/(\d{2,4})$/);
    if (m) {
      const [, dd, mm, yy] = m;
      const y2 = parseInt(yy, 10);
      const y = yy.length === 2 ? (y2 >= 70 ? 1900 + y2 : 2000 + y2) : y2;
      const d = new Date(Date.UTC(y, parseInt(mm, 10) - 1, parseInt(dd, 10)));
      if (
        d.getUTCFullYear() === y &&
        d.getUTCMonth() === (parseInt(mm, 10) - 1) &&
        d.getUTCDate() === parseInt(dd, 10)
      ) return d;
      return null;
    }
  }

  if (typeof val === 'number') {
    const ms = val < 1e12 ? val * 1000 : val;
    const d = new Date(ms);
    return isNaN(d.getTime()) ? null : d;
  }

  const d = new Date(val);
  return isNaN(d.getTime()) ? null : d;
}

function formatDateBR(value, fourDigitsYear = false) {
  if (!value) return '—';
  const d = safeDateFromAny(value);
  if (!d) return escapeHtml(String(value));
  const dd = String(d.getUTCDate()).padStart(2, '0');
  const mm = String(d.getUTCMonth() + 1).padStart(2, '0');
  const yyyy = String(d.getUTCFullYear());
  const yy = yyyy.slice(-2);
  return `${dd}/${mm}/${fourDigitsYear ? yyyy : yy}`;
}

function parseNumber(v) {
  if (v == null || (typeof v === 'string' && !v.trim())) return 0;
  if (typeof v === 'number') return Number.isFinite(v) ? v : 0;

  if (typeof v === 'string') {
    let s = v.trim();
    // Suporta formato contábil com parênteses: (1.234,56) => -1.234,56
    const isParenNeg = /^\(.*\)$/.test(s);
    if (isParenNeg) s = s.slice(1, -1);

    s = s
      .replace(/[^\d,.-]/g, '')            // mantém dígitos, ., , e sinais
      .replace(/\.(?=\d{3}(\D|$))/g, '')   // remove separador de milhar "."
      .replace(',', '.');                  // vírgula decimal -> ponto

    let n = Number(s);
    if (!Number.isFinite(n)) return 0;
    if (isParenNeg) n = -n;
    return n;
  }

  const n = Number(v);
  return Number.isFinite(n) ? n : 0;
}

const brlFmt = new Intl.NumberFormat('pt-BR', {
  style: 'currency', currency: 'BRL', maximumFractionDigits: 2,
});

const formatBRL = (n) => brlFmt.format(parseNumber(n));
const toCents = (n) => Math.round(parseNumber(n) * 100);
const fromCents = (c) => c / 100;

// ===================== Cores e Status =====================

function isConciliadoLike(status) {
  const s = norm(status);
  if (s.includes('nao conciliado')) return false;
  const isConciliadoExato = /\bconciliado\b/.test(s) && !s.includes('parcial') && !s.includes('diverg');
  const isPerfeita = s.includes('perfeita');
  return isConciliadoExato || isPerfeita;
}

function statusBg(status) {
  const s = norm(status);
  if (s.includes('nf em aberto')) return '#e3f2fd';        // azul claro
  if (s.includes('recebimento a maior')) return '#e0f7fa'; // ciano claro
  if (s.includes('pagamento a maior')) return '#f3e5f5';   // roxo claro
  if (s.includes('nao conciliado')) return '#ffebee';      // vermelho claro
  if (isConciliadoLike(s)) return '#e8f5e9';               // verde claro
  if (/\bparcial\w*|\bdiverg\w*/.test(s)) return '#fff8e1'; // amarelo claro
  return '#f5f5f5'; // neutro
}

function statusPillColor(status) {
  const s = norm(status);
  if (s.includes('nf em aberto')) return '#1565c0';        // azul
  if (s.includes('recebimento a maior')) return '#00838f'; // teal/azulado
  if (s.includes('pagamento a maior')) return '#6a1b9a';   // roxo
  if (s.includes('nao conciliado')) return '#c62828';      // vermelho
  if (isConciliadoLike(s)) return '#2e7d32';               // verde
  if (/\bparcial\w*|\bdiverg\w*/.test(s)) return '#f9a825'; // amarelo
  return '#333';
}

function getStatusPriority(status) {
  const s = norm(status);

  // Ordem (asc): Conciliado → Divergente → NF em Aberto → Recebimento a Maior → Pagamento a Maior → Não Conciliado → Outros
  if (isConciliadoLike(s)) return 1;
  if (/\bparcial\w*|\bdiverg\w*/.test(s)) return 2;
  if (/\bnf\s+em\s+aberto\b/.test(s)) return 3;
  if (/\brecebimento\s+a\s+maior\b/.test(s)) return 4;
  if (/\bpagamento\s+a\s+maior\b/.test(s)) return 5;
  if (/\bnao\s+conciliado\b/.test(s)) return 6;
  return 99;
}

function statusBucketLabel(statusRaw) {
  const s = norm(statusRaw ?? '');

  if (isConciliadoLike(s)) return 'Conciliado';
  // Variações de "parcial"/"diverg*"
  if (/\bconciliacao\s+diverg\w*/.test(s) || /\bparcial\w*/.test(s) || /\bdiverg\w*/.test(s)) {
    return 'Conciliação Divergente';
  }
  if (/\bnf\s+em\s+aberto\b/.test(s)) return 'NF em Aberto';
  if (/\brecebimento\s+a\s+maior\b/.test(s)) return 'Recebimento a Maior';
  if (/\bpagamento\s+a\s+maior\b/.test(s)) return 'Pagamento a Maior';
  if (/\bnao\s+conciliado\b/.test(s)) return 'Não Conciliado';

  return 'Não Encontrado/Outros';
}

// ===================== Helpers =====================

function toArrayLaunch(v) {
  if (Array.isArray(v)) return v;
  if (v == null) return [];
  if (typeof v === 'string') return v.split(',').map(s => s.trim()).filter(Boolean);
  return [String(v)];
}

// Detecta se um objeto é claramente "config" (sort/showDetails) e não uma linha de dados
function isConfigItem(obj) {
  if (!obj || typeof obj !== 'object') return false;

  // Se trouxer um array de dados, não é config
  if (Array.isArray(obj.data)) return false;

  const configKeys = new Set(['sortorder', 'order', 'sortfield', 'field', 'sortby', 'showdetails']);
  const keys = Object.keys(obj).map(k => k.toLowerCase());

  const hasAnyConfig = keys.some(k => configKeys.has(k));
  if (!hasAnyConfig) return false;

  // Se também tiver indícios de linha, então NÃO trate como config
  const rowHints = ['nf','status','valor_creditado','valor debitado','valor_debitado','credito','debito','data','date','dt','dt_emissao','emissao','cnpj','empresa'];
  const hasRowHints = keys.some(k => rowHints.includes(k));
  return !hasRowHints;
}

function normalizeRows(items) {
  const rows = [];
  for (let idx = 0; idx < (items?.length ?? 0); idx++) {
    const it = items[idx];

    // Preferência: array em json.data
    if (Array.isArray(it?.json?.data)) {
      rows.push(...it.json.data);
      continue;
    }

    // Objeto em it.json
    if (it?.json && typeof it.json === 'object') {
      if (!isConfigItem(it.json)) rows.push(it.json);
      continue;
    }

    // Objeto "cru"
    if (it && typeof it === 'object') {
      rows.push(it);
    }
  }
  return rows;
}

function pickDateCell(r, preferredField) {
  return preferredField && r?.[preferredField] != null
    ? r[preferredField]
    : (r.data ?? r.date ?? r.dt ?? r.data_nf ?? r.dt_emissao ?? r.emissao ?? r.emissão ?? r.data_lancamento ?? null);
}

// ---------- Config ----------
function getSortConfig(items) {
  const cfg = items?.[0]?.json || {};
  const orderRaw = (cfg.sortOrder || cfg.order || '').toString().toLowerCase();
  const sortOrder = (orderRaw === 'desc' || orderRaw === 'descending') ? 'desc' : 'asc';
  const sortField = cfg.sortField || cfg.field || null;
  const sortBy = (cfg.sortBy || 'status+date').toLowerCase();
  return { sortOrder, sortField, sortBy };
}

// ===================== Histórico =====================

function deriveHistory(r) {
  const origem = r?.historico_origem;
  let full = '';
  if (origem) {
    full = String(origem);
  } else {
    const hc = Array.isArray(r?.historico_credito) ? r.historico_credito : (r?.historico_credito ? [r.historico_credito] : []);
    const hd = Array.isArray(r?.historico_debito) ? r.historico_debito : (r?.historico_debito ? [r.historico_debito] : []);
    const uniq = [...new Set([...hc, ...hd].filter(Boolean).map(String))];
    full = uniq.join(' | ');
  }
  const trimmed = full.trim();
  if (!trimmed) return { display: '—', title: '' };

  const maxLen = 120;
  const display = trimmed.length > maxLen ? trimmed.slice(0, maxLen) + '…' : trimmed;
  return { display: escapeHtml(display), title: escapeHtml(trimmed) };
}

// ===================== Leitura flexível & Saldo Exercício =====================

function normalizeKeyName(k) {
  const base = String(k ?? '').toLowerCase().normalize('NFD');
  let noDia;
  try {
    noDia = base.replace(/\p{Diacritic}/gu, '');
  } catch {
    noDia = base.replace(/[\u0300-\u036f]/g, '');
  }
  return noDia.replace(/[^a-z0-9]/g, '');
}

function pickFlexibleField(obj, candidateNames) {
  if (!obj || typeof obj !== 'object') return undefined;
  const map = new Map();
  for (const key of Object.keys(obj)) {
    map.set(normalizeKeyName(key), key);
  }
  const targets = candidateNames.map(normalizeKeyName);

  for (const t of targets) if (map.has(t)) return obj[map.get(t)];
  for (const t of targets) for (const [nk, orig] of map.entries()) if (nk.startsWith(t)) return obj[orig];
  for (const t of targets) for (const [nk, orig] of map.entries()) if (nk.includes(t)) return obj[orig];

  return undefined;
}

function readMoneyFieldFlexible(obj, candidateNames) {
  const v = pickFlexibleField(obj, candidateNames);
  if (v === undefined || v === null || (typeof v === 'string' && v.trim() === '')) return null;
  return toCents(v);
}

// Regra: Saldo Exercício = Débito − Crédito (fallback)
function getSaldoExercicioCents(r, creditoCents, debitoCents) {
  const explicit = readMoneyFieldFlexible(r, [
    'saldo_exercicio', 'saldo exercicio', 'saldo-exercicio', 'saldoExercicio',
    'saldo_exerc', 'saldo_exercicio_total', 'saldo_exercício', 'saldo'
  ]);
  if (explicit !== null) return explicit;
  const c = Number.isFinite(creditoCents) ? creditoCents : 0;
  const d = Number.isFinite(debitoCents) ? debitoCents : 0;
  return d - c;
}

// ===================== HTML Builder (com toggle e regras de detalhes) =====================

function firstNonEmpty(rows, keys) {
  for (const r of rows) {
    for (const k of keys) {
      const v = r?.[k];
      if (v !== undefined && v !== null && String(v).trim() !== '') return v;
    }
  }
  return null;
}

function renderTotalsCards(totals, totalGeralCredito, totalGeralDebito) {
  const ORDER = [
    'Conciliado',
    'Conciliação Divergente',
    'NF em Aberto',
    'Recebimento a Maior',
    'Pagamento a Maior',
    'Não Conciliado',
    'Não Encontrado/Outros',
  ];

  const STYLE = {
    'Conciliado': { bg:'#e8f5e9', border:'rgba(46,125,50,.2)', color:'#2e7d32' },
    'Conciliação Divergente': { bg:'#fff8e1', border:'rgba(249,168,37,.2)', color:'#f9a825' },
    'NF em Aberto': { bg:'#e3f2fd', border:'rgba(21,101,192,.2)', color:'#1565c0' },
    'Recebimento a Maior': { bg:'#e0f7fa', border:'rgba(0,131,143,.2)', color:'#00838f' },
    'Pagamento a Maior': { bg:'#f3e5f5', border:'rgba(106,27,154,.2)', color:'#6a1b9a' },
    'Não Conciliado': { bg:'#ffebee', border:'rgba(198,40,40,.2)', color:'#c62828' },
    'Não Encontrado/Outros': { bg:'#eeeeee', border:'#ccc', color:'#333' },
  };

  const cardsHtml = ORDER
    .filter(lbl => (totals[lbl]?.count || 0) > 0) // esconde vazios
    .map(lbl => {
      const t = totals[lbl];
      const st = STYLE[lbl];
      return `
  <div style="background:${st.bg};border:1px solid ${st.border};border-radius:12px;padding:12px">
    <div style="font-size:12px;color:${st.color}">${lbl}</div>
    <div style="font-weight:700">${t.count} lanç.</div>
    <div style="font-size:12px">Crédito ${formatBRL(fromCents(t.credito))} · Débito ${formatBRL(fromCents(t.debito))}</div>
  </div>`;
    }).join('');

  const totalCard = `
  <div style="background:#f5f5f5;border:1px solid #ddd;border-radius:12px;padding:12px">
    <div style="font-size:12px;color:#333">Total Geral</div>
    <div style="font-weight:700">Saldo: ${formatBRL(fromCents(totalGeralDebito - totalGeralCredito))}</div>
    <div style="font-size:12px">Crédito ${formatBRL(fromCents(totalGeralCredito))} · Débito ${formatBRL(fromCents(totalGeralDebito))}</div>
  </div>`;

  return `<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));gap:12px;margin:12px 0 12px 0">
${cardsHtml}
${totalCard}
</div>`;
}

function buildHtml(rows, sortOrder, sortField, sortBy, showDetails) {
  const empresa = escapeHtml(rows[0]?.empresa ?? '');
  const cnpj = escapeHtml(rows[0]?.cnpj ?? '');

  // conta_* dos itens (primeiro não-vazio)
  const contaNumeroRaw   = firstNonEmpty(rows, ['conta_numero', 'conta_num']);
  const contaCodigoRaw   = firstNonEmpty(rows, ['conta_codigo', 'conta_cod']);
  const contaDescrRaw    = firstNonEmpty(rows, ['conta_descricao', 'conta_desc']);

  const contaNumero = contaNumeroRaw == null ? '—' : escapeHtml(String(contaNumeroRaw));
  const contaCodigo = contaCodigoRaw == null ? '—' : escapeHtml(String(contaCodigoRaw));
  const contaDescr  = contaDescrRaw  == null ? '—' : escapeHtml(String(contaDescrRaw));

  // Precompute helpers
  const prepared = rows.map((r, idx) => {
    const dateCell = pickDateCell(r, sortField);
    const d = safeDateFromAny(dateCell);
    const ts = d ? d.getTime() : new Date('1900-01-01T00:00:00Z').getTime();

    const creditoCents = (readMoneyFieldFlexible(r, ['valor_creditado', 'credito', 'valor credito']) ?? 0);
    const debitoCents = (readMoneyFieldFlexible(r, ['valor_debitado', 'debito', 'valor debito']) ?? 0);

    const nfKey = String(r.nf ?? '').padStart(20, '0');
    const statusPri = getStatusPriority(r.status);
    const statusRaw = r.status ?? '';
    const statusGroup = statusBucketLabel(statusRaw);

    return { r, idx, ts, creditoCents, debitoCents, nfKey, statusPri, dateCell, statusRaw, statusGroup };
  });

  // Ordenação (com estabilidade por grupo)
  prepared.sort((A, B) => {
    const a = A, b = B;
    let diff = 0;

    if (sortBy === 'status' || sortBy === 'status+date') {
      diff = a.statusPri - b.statusPri;
      if (diff !== 0) return sortOrder === 'desc' ? -diff : diff;
      diff = a.statusGroup.localeCompare(b.statusGroup);
      if (diff !== 0) return sortOrder === 'desc' ? -diff : diff;
    }

    if (sortBy === 'date' || sortBy === 'status+date') {
      diff = a.ts - b.ts;
      if (diff !== 0) return sortOrder === 'desc' ? -diff : diff;
    }

    diff = a.nfKey.localeCompare(b.nfKey) || (a.creditoCents - b.creditoCents) || (a.idx - b.idx);
    return sortOrder === 'desc' ? -diff : diff;
  });

  // Totais em centavos (cards)
  const totals = {
    'Conciliado': { count: 0, credito: 0, debito: 0 },
    'Conciliação Divergente': { count: 0, credito: 0, debito: 0 },
    'NF em Aberto': { count: 0, credito: 0, debito: 0 },
    'Recebimento a Maior': { count: 0, credito: 0, debito: 0 },
    'Pagamento a Maior': { count: 0, credito: 0, debito: 0 },
    'Não Conciliado': { count: 0, credito: 0, debito: 0 },
    'Não Encontrado/Outros': { count: 0, credito: 0, debito: 0 },
  };
  let totalGeralCredito = 0;
  let totalGeralDebito = 0;

  function renderSubtotalRow(label, creditoSum, debitoSum) {
    const safe = escapeHtml(String(label ?? ''));
    return `
<tr style="background:#d7d7d7">
  <td colspan="2" style="font-weight:700">Subtotal — ${safe}</td>
  <td class="right" style="font-weight:700">${formatBRL(fromCents(creditoSum))}</td>
  <td class="right" style="font-weight:700">${formatBRL(fromCents(debitoSum))}</td>
  <td colspan="4"> </td>
</tr>`;
  }

  function renderHeaderRow() {
    return `
<tr>
  <th>Data</th>
  <th>NF</th>
  <th class="right">Valor Creditado</th>
  <th class="right">Valor Debitado</th>
  <th>Histórico</th>
  <th>Status</th>
  <th>Lanç. Crédito</th>
  <th>Lanç. Débito</th>
</tr>`;
  }

  // Linhas detalhadas por lançamento (filhas)
  function renderDetalheRows(r) {
    const cred = Array.isArray(r.detalhes_credito) ? r.detalhes_credito : [];
    const deb  = Array.isArray(r.detalhes_debito)  ? r.detalhes_debito  : [];

    let html = '';

    for (const l of cred) {
      const data = l?.data ? formatDateBR(l.data, false) : '—';
      const num  = l?.numero == null ? '—' : escapeHtml(String(l.numero));
      const val  = formatBRL(l?.valor ?? 0);
      const hist = l?.historico ? escapeHtml(String(l.historico)) : '';

      html += `
<tr class="det" style="background:#f8fbff">
  <td style="padding-left:22px">${data}</td>
  <td>—</td>
  <td class="right">${val}</td>
  <td class="right">—</td>
  <td class="hist">${hist}</td>
  <td style="color:#1565c0;font-size:12px">Crédito</td>
  <td>${num}</td>
  <td>—</td>
</tr>`;
    }

    for (const l of deb) {
      const data = l?.data ? formatDateBR(l.data, false) : '—';
      const num  = l?.numero == null ? '—' : escapeHtml(String(l.numero));
      const val  = formatBRL(l?.valor ?? 0);
      const hist = l?.historico ? escapeHtml(String(l.historico)) : '';

      html += `
<tr class="det" style="background:#fbf8ff">
  <td style="padding-left:22px">${data}</td>
  <td>—</td>
  <td class="right">—</td>
  <td class="right">${val}</td>
  <td class="hist">${hist}</td>
  <td style="color:#6a1b9a;font-size:12px">Débito</td>
  <td>—</td>
  <td>${num}</td>
</tr>`;
    }

    return html;
  }

  let bodyRows = '';
  let currentGroup = null;
  let groupCred = 0;
  let groupDeb = 0;

  // Status que NÃO devem exibir detalhes (independente do toggle) — use os rótulos exibidos
  const NO_DETAILS_GROUPS = new Set(['NF em Aberto', 'Recebimento a Maior', 'Pagamento a Maior']);

  for (const { r, creditoCents, debitoCents, dateCell, statusRaw, statusGroup } of prepared) {
    if (currentGroup === null) {
      currentGroup = statusGroup;
      groupCred = 0;
      groupDeb = 0;
    } else if (statusGroup !== currentGroup) {
      bodyRows += renderSubtotalRow(currentGroup, groupCred, groupDeb);
      bodyRows += renderHeaderRow();
      currentGroup = statusGroup;
      groupCred = 0;
      groupDeb = 0;
    }

    groupCred += creditoCents;
    groupDeb += debitoCents;

    const bucket = statusGroup;
    totals[bucket] ??= { count: 0, credito: 0, debito: 0 };
    totals[bucket].count += 1;
    totals[bucket].credito += creditoCents;
    totals[bucket].debito += debitoCents;
    totalGeralCredito += creditoCents;
    totalGeralDebito += debitoCents;

    const dataFmt = formatDateBR(dateCell);
    const nf = (r.nf === null || r.nf === undefined || r.nf === '') ? '—' : escapeHtml(String(r.nf));
    const lcredArr = toArrayLaunch(r.lancamento_credito);
    const ldebArr = toArrayLaunch(r.lancamento_debito);
    const lcred = lcredArr.length ? escapeHtml(lcredArr.join(', ')) : '—';
    const ldeb = ldebArr.length ? escapeHtml(ldebArr.join(', ')) : '—';
    const hist = deriveHistory(r);
    const pillColor = statusPillColor(statusRaw);
    const statusTxt = escapeHtml(String(statusRaw));

    // Linha "resumo" agregada por NF
    bodyRows += `
<tr style="background:${statusBg(statusRaw)}">
  <td>${dataFmt}</td>
  <td>${nf}</td>
  <td class="right">${formatBRL(fromCents(creditoCents))}</td>
  <td class="right">${formatBRL(fromCents(debitoCents))}</td>
  <td class="hist" title="${hist.title}">${hist.display}</td>
  <td>
    <span style="
      display:inline-block;padding:.25rem .5rem;border-radius:999px;font-weight:600;
      color:${pillColor};border:1px solid rgba(0,0,0,.08);background:#fff
    ">${statusTxt}</span>
  </td>
  <td>${lcred}</td>
  <td>${ldeb}</td>
</tr>`;

    // Linhas detalhadas por lançamento (se existirem):
    // - respeita o toggle showDetails
    // - mas NUNCA renderiza para grupos definidos em NO_DETAILS_GROUPS
    if (showDetails && !NO_DETAILS_GROUPS.has(statusGroup)) {
      if ((Array.isArray(r.detalhes_credito) && r.detalhes_credito.length) ||
          (Array.isArray(r.detalhes_debito)  && r.detalhes_debito.length)) {
        bodyRows += renderDetalheRows(r);
      }
    }
  }

  if (currentGroup !== null) {
    bodyRows += renderSubtotalRow(currentGroup, groupCred, groupDeb);
  }

  const legend = `
<div style="display:flex;gap:1rem;flex-wrap:wrap;margin:.5rem 0 1rem 0;justify-content:center;align-items:center">
  <div><span style="display:inline-block;width:12px;height:12px;background:#2e7d32;border-radius:2px;margin-right:.4rem;vertical-align:middle"></span> Conciliado</div>
  <div><span style="display:inline-block;width:12px;height:12px;background:#f9a825;border-radius:2px;margin-right:.4rem;vertical-align:middle"></span> Conciliação Divergente</div>
  <div><span style="display:inline-block;width:12px;height:12px;background:#1565c0;border-radius:2px;margin-right:.4rem;vertical-align:middle"></span> NF em Aberto</div>
  <div><span style="display:inline-block;width:12px;height:12px;background:#00838f;border-radius:2px;margin-right:.4rem;vertical-align:middle"></span> Recebimento a Maior</div>
  <div><span style="display:inline-block;width:12px;height:12px;background:#6a1b9a;border-radius:2px;margin-right:.4rem;vertical-align:middle"></span> Pagamento a Maior</div>
  <div><span style="display:inline-block;width:12px;height:12px;background:#c62828;border-radius:2px;margin-right:.4rem;vertical-align:middle"></span> Não Conciliado</div>
  <div><span style="display:inline-block;width:12px;height:12px;background:#9e9e9e;border-radius:2px;margin-right:.4rem;vertical-align:middle"></span> Não Encontrado/Outros</div>
</div>`;

  const totalsHtml = renderTotalsCards(totals, totalGeralCredito, totalGeralDebito);

  const contaInfoHtml = `
<div style="text-align:center;margin:8px 0 20px 0;color:#222;font-weight:900;font-size:1.25rem">
${contaNumero} · ${contaCodigo} · ${contaDescr}
</div>`;

  const generatedAt = new Date().toLocaleString('pt-BR', { timeZone: 'America/Sao_Paulo' });

  // --- TOGGLE button + script
  const controlsHtml = `
<div style="display:flex;justify-content:center;margin:8px 0 16px 0">
  <button id="toggleDetails" onclick="toggleDetails()" aria-pressed="false" style="
    border:1px solid #ddd;border-radius:999px;padding:.4rem .9rem;background:#fff;cursor:pointer;
    font-weight:600
  ">${showDetails ? 'Ocultar detalhes' : 'Mostrar detalhes'}</button>
</div>`;

  const toggleScript = `
<script>
(function(){
  const LS_KEY = 'relatorio_show_details';
  const initial = ${showDetails ? 'true' : 'false'};
  let show = (function(){
    try {
      const raw = localStorage.getItem(LS_KEY);
      return raw == null ? initial : JSON.parse(raw);
    } catch { return initial; }
  })();

  function apply(){
    var rows = document.querySelectorAll('tr.det');
    for (var i=0;i<rows.length;i++){ rows[i].style.display = show ? '' : 'none'; }
    var btn = document.getElementById('toggleDetails');
    if (btn){
      btn.textContent = show ? 'Ocultar detalhes' : 'Mostrar detalhes';
      btn.setAttribute('aria-pressed', show ? 'true' : 'false');
    }
  }

  window.toggleDetails = function(){
    show = !show;
    try { localStorage.setItem(LS_KEY, JSON.stringify(show)); } catch {}
    apply();
  };

  if (!show) {
    // evita "flash" de detalhes quando estado inicial é oculto
    document.addEventListener('DOMContentLoaded', function(){
      var style = document.createElement('style');
      style.id = 'detHiddenInit';
      style.textContent = 'tr.det{display:none}';
      document.head.appendChild(style);
      apply();
      var s = document.getElementById('detHiddenInit');
      if (s) setTimeout(function(){ s.parentNode && s.parentNode.removeChild(s); }, 0);
    });
  } else {
    document.addEventListener('DOMContentLoaded', apply);
  }
})();
</script>`;

  return `<!doctype html>
<html lang="pt-br">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Relatório de Conciliação</title>
<style>
  body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Oxygen,Ubuntu,'Helvetica Neue',Arial,sans-serif;margin:24px;line-height:1.4}
  h1{margin:0 0 4px 0;font-weight:700;color:#222;font-size:1.7rem;text-align:center}
  .sub{font-size:12px;color:#444;text-align:center;margin-bottom:12px}
  table{border-collapse:collapse;width:100%}
  th,td{border:1px solid #ddd;padding:8px;vertical-align:top;color:#222}
  th{background:#f5f5f5;text-align:left}
  td{background:transparent}
  .right{text-align:right}
  .hist{max-width:520px;word-break:break-word}
  .logo{display:flex;justify-content:center;margin-bottom:16px}
  .logo img{max-height:80px}
  tr.det td{font-size:12px;border-top:none;border-bottom:1px dashed #e0e0e0}
  .toolbar{display:flex;justify-content:center;gap:8px;margin:8px 0 16px 0}
  @media print {
    body { margin: 8mm; font-size: 11px; }
    .logo { display: none; }
    table { page-break-inside: auto; }
    tr { page-break-inside: avoid; page-break-after: auto; }
    h1 { font-size: 16px; }
    #toggleDetails { display:none; }
  }
</style>
${showDetails ? '' : '<style>tr.det{display:none}</style>'}
</head>
<body>
  <div class="logo">
    <img src="https://elevagestaofinanceira.com.br/wp-content/uploads/2023/04/site_layout_eleva_LOGO_color_600x300px_03_04_23.png" alt="Logo">
  </div>
  <h1>Relatório de Conciliação - ${empresa} - ${cnpj}</h1>
  <div class="sub">Gerado em ${generatedAt}</div>
  ${legend}
  ${totalsHtml}
  ${contaInfoHtml}
  <div class="toolbar">${controlsHtml}</div>
  <table>
    <thead>
      <tr>
        <th>Data</th>
        <th>NF</th>
        <th class="right">Valor Creditado</th>
        <th class="right">Valor Debitado</th>
        <th>Histórico</th>
        <th>Status</th>
        <th>Lanç. Crédito</th>
        <th>Lanç. Débito</th>
      </tr>
    </thead>
    <tbody>
      ${bodyRows}
    </tbody>
  </table>
  ${toggleScript}
</body>
</html>`;
}

// ===================== Execução no n8n =====================

// Config adicional: parâmetro para estado inicial dos detalhes
const cfg = items?.[0]?.json || {};
const showDetails = cfg.showDetails !== false; // padrão: true

const rows = normalizeRows(items);
const { sortOrder, sortField, sortBy } = getSortConfig(items);

const html = rows.length
  ? buildHtml(rows, sortOrder, sortField, sortBy, showDetails)
  : `<!doctype html><meta charset="utf-8"><title>Relatório de Conciliação</title>
     <div style="font-family:system-ui;margin:24px">
       <h1>Relatório de Conciliação</h1>
       <p>Nenhuma linha para exibir.</p>
     </div>`;

return [
  {
    json: {
      fileName: 'relatorio_conciliacao.html',
      mimeType: 'text/html',
      note: `HTML gerado. Ordenação: ${sortBy} (${sortOrder})${sortField ? `, campo: ${sortField}` : ''}. Detalhes: ${showDetails ? 'inicialmente visíveis' : 'inicialmente ocultos'} (grupos "NF em Aberto", "Pagamento a Maior" e "Recebimento a Maior" sempre sem detalhes). Cards ocultam categorias com 0 lançamentos.`,
    },
    binary: {
      data: {
        data: Buffer.from(html, 'utf8').toString('base64'),
        mimeType: 'text/html',
        fileName: 'relatorio_conciliacao.html',
      }
    }
  }
];

// DESCOMENTA POR CONTA DO REGEX!!!
*/
