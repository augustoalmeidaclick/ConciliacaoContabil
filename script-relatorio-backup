// ===================== Utils: Números & Datas & Escapes =====================

function escapeHtml(str) {
  return String(str ?? "")
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#39;");
}

function norm(s) {
  return String(s ?? "")
    .toLowerCase()
    .normalize("NFD")
    .replace(/\p{Diacritic}/gu, "");
}

function safeDateFromAny(val) {
  if (val == null || val === "") return null;

  if (typeof val === "string") {
    const m = val.trim().match(/^(\d{1,2})\/(\d{1,2})\/(\d{2,4})$/);
    if (m) {
      const [, dd, mm, yy] = m;
      const y2 = parseInt(yy, 10);
      const y = yy.length === 2 ? (y2 >= 70 ? 1900 + y2 : 2000 + y2) : y2;
      const d = new Date(Date.UTC(y, parseInt(mm, 10) - 1, parseInt(dd, 10)));
      if (
        d.getUTCFullYear() === y &&
        d.getUTCMonth() === parseInt(mm, 10) - 1 &&
        d.getUTCDate() === parseInt(dd, 10)
      )
        return d;
      return null;
    }
  }

  if (typeof val === "number") {
    const ms = val < 1e12 ? val * 1000 : val;
    const d = new Date(ms);
    return isNaN(d.getTime()) ? null : d;
  }

  const d = new Date(val);
  return isNaN(d.getTime()) ? null : d;
}

function formatDateBR(value, fourDigitsYear = false) {
  if (!value) return "—";
  const d = safeDateFromAny(value);
  if (!d) return escapeHtml(String(value));
  const dd = String(d.getUTCDate()).padStart(2, "0");
  const mm = String(d.getUTCMonth() + 1).padStart(2, "0");
  const yyyy = String(d.getUTCFullYear());
  const yy = yyyy.slice(-2);
  return `${dd}/${mm}/${fourDigitsYear ? yyyy : yy}`;
}

function parseNumber(v) {
  if (v == null || (typeof v === "string" && !v.trim())) return 0;
  if (typeof v === "number") return Number.isFinite(v) ? v : 0;
  if (typeof v === "string") {
    const s = v
      .trim()
      .replace(/[^\d,.-]/g, "")
      .replace(/\.(?=\d{3}(\D|$))/g, "")
      .replace(",", ".");
    const n = Number(s);
    return Number.isFinite(n) ? n : 0;
  }
  const n = Number(v);
  return Number.isFinite(n) ? n : 0;
}

const brlFmt = new Intl.NumberFormat("pt-BR", {
  style: "currency",
  currency: "BRL",
  maximumFractionDigits: 2,
});

const formatBRL = (n) => brlFmt.format(parseNumber(n));
const toCents = (n) => Math.round(parseNumber(n) * 100);
const fromCents = (c) => c / 100;

// ===================== Cores e Status =====================

function statusBg(status) {
  const s = norm(status);
  if (s.includes("perfeita")) return "#e8f5e9";
  if (s.includes("parcial")) return "#fff8e1";
  return "#ffebee";
}

function statusPillColor(status) {
  const s = norm(status);
  if (s.includes("perfeita")) return "#2e7d32";
  if (s.includes("parcial")) return "#f9a825";
  return "#c62828";
}

function getStatusPriority(status) {
  const s = norm(status);

  // 1º - Conciliação Perfeita
  if (s.includes("perfeita")) return 1;

  // 2º - Não pago / Pendente
  if (
    s.includes("pendente") ||
    s.includes("nao pago") ||
    s.includes("não pago")
  )
    return 2;

  // 3º - Pagamento superior / outros
  if (s.includes("superior") || s.includes("pagamento superior")) return 3;

  // fallback
  return 99;
}

// Bucket para cards-resumo
function statusBucketLabel(statusRaw) {
  const s = norm(statusRaw ?? "");
  if (s.includes("perfeita")) return "Conciliação Perfeita";
  if (s.includes("parcial")) return "Conciliação Parcial";
  return "Não Encontrado/Outros";
}

// ===================== Helpers =====================

function toArrayLaunch(v) {
  if (Array.isArray(v)) return v;
  if (v == null) return [];
  if (typeof v === "string")
    return v
      .split(",")
      .map((s) => s.trim())
      .filter(Boolean);
  return [String(v)];
}

function normalizeRows(items) {
  const rows = [];
  for (const it of items || []) {
    const d = it?.json?.data;
    if (Array.isArray(d)) rows.push(...d);
    else if (d && typeof d === "object") rows.push(d);
    else if (it?.json && typeof it.json === "object") rows.push(it.json);
    else if (it && typeof it === "object") rows.push(it);
  }
  return rows;
}

function pickDateCell(r, preferredField) {
  return preferredField && r?.[preferredField] != null
    ? r[preferredField]
    : r.data ??
        r.date ??
        r.dt ??
        r.data_nf ??
        r.dt_emissao ??
        r.emissao ??
        null;
}

// ---------- Config ----------
function getSortConfig(items) {
  const cfg = items?.[0]?.json || {};
  const orderRaw = (cfg.sortOrder || cfg.order || "").toString().toLowerCase();
  const sortOrder =
    orderRaw === "desc" || orderRaw === "descending" ? "desc" : "asc";
  const sortField = cfg.sortField || cfg.field || null;
  const sortBy = (cfg.sortBy || "status+date").toLowerCase();
  return { sortOrder, sortField, sortBy };
}

// ===================== Histórico =====================

function deriveHistory(r) {
  const origem = r?.historico_origem;
  let full = "";
  if (origem) {
    full = String(origem);
  } else {
    const hc = Array.isArray(r?.historico_credito)
      ? r.historico_credito
      : r?.historico_credito
      ? [r.historico_credito]
      : [];
    const hd = Array.isArray(r?.historico_debito)
      ? r.historico_debito
      : r?.historico_debito
      ? [r.historico_debito]
      : [];
    const uniq = [...new Set([...hc, ...hd].filter(Boolean).map(String))];
    full = uniq.join(" | ");
  }
  const trimmed = full.trim();
  if (!trimmed) return { display: "—", title: "" };

  const maxLen = 120;
  const display =
    trimmed.length > maxLen ? trimmed.slice(0, maxLen) + "…" : trimmed;
  return { display: escapeHtml(display), title: escapeHtml(trimmed) };
}

// ===================== Leitura flexível & Cálculo do Saldo Exercício =====================

function normalizeKeyName(k) {
  return String(k ?? "")
    .toLowerCase()
    .normalize("NFD")
    .replace(/\p{Diacritic}/gu, "")
    .replace(/[^a-z0-9]/g, "");
}

function pickFlexibleField(obj, candidateNames) {
  if (!obj || typeof obj !== "object") return undefined;
  const map = new Map();
  for (const key of Object.keys(obj)) {
    map.set(normalizeKeyName(key), key);
  }
  const targets = candidateNames.map(normalizeKeyName);

  // 1) exato
  for (const t of targets) if (map.has(t)) return obj[map.get(t)];
  // 2) começa com
  for (const t of targets)
    for (const [nk, orig] of map.entries())
      if (nk.startsWith(t)) return obj[orig];
  // 3) contém
  for (const t of targets)
    for (const [nk, orig] of map.entries())
      if (nk.includes(t)) return obj[orig];

  return undefined;
}

function readMoneyFieldFlexible(obj, candidateNames) {
  const v = pickFlexibleField(obj, candidateNames);
  if (
    v === undefined ||
    v === null ||
    (typeof v === "string" && v.trim() === "")
  )
    return null;
  return toCents(v);
}

// Regra: Saldo Exercício = Débito − Crédito (fallback)
function getSaldoExercicioCents(r, creditoCents, debitoCents) {
  // 1) Se houver um campo explícito, usa ele (aceita várias grafias)
  const explicit = readMoneyFieldFlexible(r, [
    "saldo_exercicio",
    "saldo exercicio",
    "saldo-exercicio",
    "saldoExercicio",
    "saldo_exerc",
    "saldo_exercicio_total",
    "saldo_exercício",
    "saldo",
  ]);
  if (explicit !== null) return explicit;

  // 2) Caso contrário, calcula: débito − crédito
  const c = Number.isFinite(creditoCents) ? creditoCents : 0;
  const d = Number.isFinite(debitoCents) ? debitoCents : 0;
  return d - c;
}

// ===================== HTML Builder =====================

function buildHtml(rows, sortOrder, sortField, sortBy) {
  const empresa = escapeHtml(rows[0]?.empresa ?? "");
  const cnpj = escapeHtml(rows[0]?.cnpj ?? "");

  // Precompute helpers por performance e sort estável
  const prepared = rows.map((r, idx) => {
    const dateCell = pickDateCell(r, sortField);
    const d = safeDateFromAny(dateCell);
    const ts = d ? d.getTime() : new Date("1900-01-01T00:00:00Z").getTime();

    // Crédito/Débito com fallback de nomes
    const creditoCents =
      readMoneyFieldFlexible(r, [
        "valor_creditado",
        "credito",
        "valor credito",
      ]) ?? 0;
    const debitoCents =
      readMoneyFieldFlexible(r, ["valor_debitado", "debito", "valor debito"]) ??
      0;

    const nfKey = String(r.nf ?? "").padStart(20, "0");
    const statusPri = getStatusPriority(r.status);

    return {
      r,
      idx,
      ts,
      creditoCents,
      debitoCents,
      nfKey,
      statusPri,
      dateCell,
      statusRaw: r.status ?? "",
    };
  });

  // --- Ordenação dinâmica (estável) ---
  prepared.sort((A, B) => {
    const a = A,
      b = B;
    let diff = 0;

    if (sortBy === "status" || sortBy === "status+date") {
      // agrupa por status primeiro (para subtotais)
      diff = a.statusPri - b.statusPri;
      if (diff !== 0) return sortOrder === "desc" ? -diff : diff;
    }

    if (sortBy === "date" || sortBy === "status+date") {
      diff = a.ts - b.ts;
      if (diff !== 0) return sortOrder === "desc" ? -diff : diff;
    }

    // tie-breaker determinístico
    diff =
      a.nfKey.localeCompare(b.nfKey) ||
      a.creditoCents - b.creditoCents ||
      a.idx - b.idx;
    return sortOrder === "desc" ? -diff : diff;
  });

  // Totais em centavos (cards)
  const totals = {
    "Conciliação Perfeita": { count: 0, credito: 0, debito: 0 },
    "Conciliação Parcial": { count: 0, credito: 0, debito: 0 },
    "Não Encontrado/Outros": { count: 0, credito: 0, debito: 0 },
  };
  let totalGeralCredito = 0;
  let totalGeralDebito = 0;

  // Helper: linha de subtotal por grupo
  function renderSubtotalRow(statusLabel, creditoSum, debitoSum) {
    return `
<tr style="background:#d7d7d7">
  <td colspan="2" style="font-weight:700">Subtotal</td>
  <td class="right" style="font-weight:700">${formatBRL(
    fromCents(creditoSum)
  )}</td>
  <td class="right" style="font-weight:700">${formatBRL(
    fromCents(debitoSum)
  )}</td>
  <td colspan="4"> </td>
</tr>`;
  }

  // Cabeçalho repetido dentro do <tbody>, usado após cada subtotal
  function renderHeaderRow() {
    return `
<tr>
  <th>Data</th>
  <th>NF</th>
  <th class="right">Valor Creditado</th>
  <th class="right">Valor Debitado</th>
  <th>Histórico</th>
  <th>Status</th>
  <!-- <th class="right">Saldo Exercício</th> -->
  <th>Lanç. Crédito</th>
  <th>Lanç. Débito</th>
</tr>`;
  }

  // Construção do corpo com subtotais por **statusRaw** e cabeçalho logo após cada subtotal
  let bodyRows = "";
  let currentLabel = null;
  let groupCred = 0;
  let groupDeb = 0;

  for (const {
    r,
    creditoCents,
    debitoCents,
    dateCell,
    statusRaw,
  } of prepared) {
    // inicia/fecha grupo
    if (currentLabel === null) {
      currentLabel = statusRaw;
      groupCred = 0;
      groupDeb = 0;
    } else if (statusRaw !== currentLabel) {
      // fecha grupo anterior com subtotal
      bodyRows += renderSubtotalRow(currentLabel, groupCred, groupDeb);
      // imediatamente abaixo do Subtotal, insere o cabeçalho para o próximo grupo
      bodyRows += renderHeaderRow();

      currentLabel = statusRaw;
      groupCred = 0;
      groupDeb = 0;
    }

    // acumula para grupo atual
    groupCred += creditoCents;
    groupDeb += debitoCents;

    // acumula para cards (bucket genérico)
    const bucket = statusBucketLabel(statusRaw);
    totals[bucket].count += 1;
    totals[bucket].credito += creditoCents;
    totals[bucket].debito += debitoCents;
    totalGeralCredito += creditoCents;
    totalGeralDebito += debitoCents;

    // linha normal
    const dataFmt = formatDateBR(dateCell);
    const nf =
      r.nf === null || r.nf === undefined || r.nf === ""
        ? "—"
        : escapeHtml(String(r.nf));
    const lcredArr = toArrayLaunch(r.lancamento_credito);
    const ldebArr = toArrayLaunch(r.lancamento_debito);
    const lcred = lcredArr.length ? escapeHtml(lcredArr.join(", ")) : "—";
    const ldeb = ldebArr.length ? escapeHtml(ldebArr.join(", ")) : "—";
    const saldoExCents = getSaldoExercicioCents(r, creditoCents, debitoCents);
    const hist = deriveHistory(r);
    const pillColor = statusPillColor(statusRaw);
    const statusTxt = escapeHtml(String(statusRaw));

    bodyRows += `
<tr style="background:${statusBg(statusRaw)}">
  <td>${dataFmt}</td>
  <td>${nf}</td>
  <td class="right">${formatBRL(fromCents(creditoCents))}</td>
  <td class="right">${formatBRL(fromCents(debitoCents))}</td>
  <td class="hist" title="${hist.title}">${hist.display}</td>
  <td>
    <span style="
      display:inline-block;padding:.25rem .5rem;border-radius:999px;font-weight:600;
      color:${pillColor};border:1px solid rgba(0,0,0,.08);background:#fff
    ">${statusTxt}</span>
  </td>
  <!-- <td class="right">${formatBRL(fromCents(saldoExCents))}</td> -->
  <td>${lcred}</td>
  <td>${ldeb}</td>
</tr>`;
  }

  // fecha o último grupo se houver linhas
  if (currentLabel !== null) {
    bodyRows += renderSubtotalRow(currentLabel, groupCred, groupDeb);
  }

  // (REMOVIDO) Linha final Totais do Relatório

  const legend = `
<div style="display:flex;gap:1rem;flex-wrap:wrap;margin:.5rem 0 1rem 0">
  <div><span style="display:inline-block;width:12px;height:12px;background:#e8f5e9;border:1px solid rgba(46,125,50,.2);margin-right:.4rem;vertical-align:middle"></span> Conciliação Perfeita</div>
  <div><span style="display:inline-block;width:12px;height:12px;background:#fff8e1;border:1px solid rgba(249,168,37,.2);margin-right:.4rem;vertical-align:middle"></span> Conciliação Parcial</div>
  <div><span style="display:inline-block;width:12px;height:12px;background:#ffebee;border:1px solid rgba(198,40,40,.2);margin-right:.4rem;vertical-align:middle"></span> Não Encontrado / Pendente / Outros</div>
</div>`;

  const totalsHtml = `
<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));gap:12px;margin:12px 0 20px 0">
  <div style="background:#e8f5e9;border:1px solid rgba(46,125,50,.2);border-radius:12px;padding:12px">
    <div style="font-size:12px;color:#2e7d32">Conciliação Perfeita</div>
    <div style="font-weight:700">${
      totals["Conciliação Perfeita"].count
    } lanç.</div>
    <div style="font-size:12px">Crédito ${formatBRL(
      fromCents(totals["Conciliação Perfeita"].credito)
    )} · Débito ${formatBRL(
    fromCents(totals["Conciliação Perfeita"].debito)
  )}</div>
  </div>
  <div style="background:#fff8e1;border:1px solid rgba(249,168,37,.2);border-radius:12px;padding:12px">
    <div style="font-size:12px;color:#f9a825">Conciliação Parcial</div>
    <div style="font-weight:700">${
      totals["Conciliação Parcial"].count
    } lanç.</div>
    <div style="font-size:12px">Crédito ${formatBRL(
      fromCents(totals["Conciliação Parcial"].credito)
    )} · Débito ${formatBRL(
    fromCents(totals["Conciliação Parcial"].debito)
  )}</div>
  </div>
  <div style="background:#ffebee;border:1px solid rgba(198,40,40,.2);border-radius:12px;padding:12px">
    <div style="font-size:12px;color:#c62828">Não Encontrado/Outros</div>
    <div style="font-weight:700">${
      totals["Não Encontrado/Outros"].count
    } lanç.</div>
    <div style="font-size:12px">Crédito ${formatBRL(
      fromCents(totals["Não Encontrado/Outros"].credito)
    )} · Débito ${formatBRL(
    fromCents(totals["Não Encontrado/Outros"].debito)
  )}</div>
  </div>
  <div style="background:#f5f5f5;border:1px solid #ddd;border-radius:12px;padding:12px">
    <div style="font-size:12px;color:#333">Total Geral</div>
    <div style="font-weight:700">Saldo: ${formatBRL(
      fromCents(totalGeralCredito - totalGeralDebito)
    )}</div>
    <div style="font-size:12px">Crédito ${formatBRL(
      fromCents(totalGeralCredito)
    )} · Débito ${formatBRL(fromCents(totalGeralDebito))}</div>
  </div>
</div>`;

  const generatedAt = new Date().toLocaleString("pt-BR", {
    timeZone: "America/Sao_Paulo",
  });

  return `<!doctype html>
<html lang="pt-br">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Relatório de Conciliação</title>
<style>
  body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Oxygen,Ubuntu,'Helvetica Neue',Arial,sans-serif;margin:24px;line-height:1.4}
  h1{margin:0 0 4px 0;font-weight:700;color:#222;font-size:1.7rem}
  .sub{font-size:12px;color:#444}
  table{border-collapse:collapse;width:100%}
  th,td{border:1px solid #ddd;padding:8px;vertical-align:top;color:#222}
  th{background:#f5f5f5;text-align:left}
  td{background:transparent}
  .right{text-align:right}
  .hist{max-width:520px;word-break:break-word}
</style>
</head>
<body>
  <h1>Relatório de Conciliação - ${empresa} - ${cnpj}</h1>
  <div class="sub">Gerado em ${generatedAt}</div>
  ${legend}
  ${totalsHtml}
  <table>
    <thead>
      <tr>
        <th>Data</th>
        <th>NF</th>
        <th class="right">Valor Creditado</th>
        <th class="right">Valor Debitado</th>
        <th>Histórico</th>
        <th>Status</th>
        <!-- <th class="right">Saldo Exercício</th> -->
        <th>Lanç. Crédito</th>
        <th>Lanç. Débito</th>
      </tr>
    </thead>
    <tbody>
      ${bodyRows}
    </tbody>
  </table>
</body>
</html>`;
}

// ===================== Execução no n8n =====================

const rows = normalizeRows(items);
const { sortOrder, sortField, sortBy } = getSortConfig(items);

const html = rows.length
  ? buildHtml(rows, sortOrder, sortField, sortBy)
  : `<!doctype html><meta charset="utf-8"><title>Relatório de Conciliação</title>
     <div style="font-family:system-ui;margin:24px">
       <h1>Relatório de Conciliação</h1>
       <p>Nenhuma linha para exibir.</p>
     </div>`;

return [
  {
    json: {
      fileName: "relatorio_conciliacao.html",
      mimeType: "text/html",
      note: `HTML gerado. Ordenação: ${sortBy} (${sortOrder})${
        sortField ? `, campo: ${sortField}` : ""
      }.`,
    },
    binary: {
      data: {
        data: Buffer.from(html, "utf8").toString("base64"),
        mimeType: "text/html",
        fileName: "relatorio_conciliacao.html",
      },
    },
  },
];
